import { Command } from "../command.ts";
import { ValidationError } from "../../flags/_errors.ts";
import { EnumType } from "../types/enum.ts";
export class UpgradeCommand extends Command {
  providers;
  constructor({ provider, main, args, importMap }){
    super();
    this.providers = Array.isArray(provider) ? provider : [
      provider
    ];
    if (!this.providers.length) {
      throw new Error(`No upgrade provider defined!`);
    }
    this.description(()=>`Upgrade ${this.getMainCommand().getName()} executable to latest or given version.`).noGlobals().type("provider", new EnumType(this.getProviderNames())).option("-r, --registry <name:provider>", `The registry name from which to upgrade.`, {
      default: this.getProvider().name,
      hidden: this.providers.length < 2,
      value: (registry)=>this.getProvider(registry)
    }).option("-l, --list-versions", "Show available versions.", {
      action: async ({ registry })=>{
        await registry.listVersions(this.getMainCommand().getName(), this.getVersion());
        Deno.exit(0);
      }
    }).option("--version <version:string:version>", "The version to upgrade to.", {
      default: "latest"
    }).option("-f, --force", "Replace current installation even if not out-of-date.").complete("version", ()=>this.getAllVersions()).action(async ({ registry, version: targetVersion, force })=>{
      const name = this.getMainCommand().getName();
      const currentVersion = this.getVersion();
      if (force || !currentVersion || await registry.isOutdated(name, currentVersion, targetVersion)) {
        await registry.upgrade({
          name,
          main,
          importMap,
          from: currentVersion,
          to: targetVersion,
          args
        });
      }
    });
  }
  async getAllVersions() {
    const { versions } = await this.getVersions();
    return versions;
  }
  async getLatestVersion() {
    const { latest } = await this.getVersions();
    return latest;
  }
  getVersions() {
    return this.getProvider().getVersions(this.getMainCommand().getName());
  }
  getProvider(name) {
    const provider = name ? this.providers.find((provider)=>provider.name === name) : this.providers[0];
    if (!provider) {
      throw new ValidationError(`Unknown provider "${name}"`);
    }
    return provider;
  }
  getProviderNames() {
    return this.providers.map((provider)=>provider.name);
  }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3gvY2xpZmZ5QHYwLjI1LjcvY29tbWFuZC91cGdyYWRlL3VwZ3JhZGVfY29tbWFuZC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21tYW5kIH0gZnJvbSBcIi4uL2NvbW1hbmQudHNcIjtcbmltcG9ydCB7IFZhbGlkYXRpb25FcnJvciB9IGZyb20gXCIuLi8uLi9mbGFncy9fZXJyb3JzLnRzXCI7XG5pbXBvcnQgdHlwZSB7IFByb3ZpZGVyLCBWZXJzaW9ucyB9IGZyb20gXCIuL3Byb3ZpZGVyLnRzXCI7XG5pbXBvcnQgeyBFbnVtVHlwZSB9IGZyb20gXCIuLi90eXBlcy9lbnVtLnRzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBncmFkZUNvbW1hbmRPcHRpb25zPFxuICBUUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlciA9IFByb3ZpZGVyLFxuICBUUHJvdmlkZXJzIGV4dGVuZHMgVFByb3ZpZGVyIHwgQXJyYXk8VFByb3ZpZGVyPiA9XG4gICAgfCBUUHJvdmlkZXJcbiAgICB8IEFycmF5PFRQcm92aWRlcj4sXG4+IHtcbiAgcHJvdmlkZXI6IFRQcm92aWRlcnM7XG4gIG1haW4/OiBzdHJpbmc7XG4gIGltcG9ydE1hcD86IHN0cmluZztcbiAgYXJncz86IEFycmF5PHN0cmluZz47XG59XG5cbmV4cG9ydCBjbGFzcyBVcGdyYWRlQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBwcml2YXRlIHJlYWRvbmx5IHByb3ZpZGVyczogUmVhZG9ubHlBcnJheTxQcm92aWRlcj47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgeyBwcm92aWRlciwgbWFpbiwgYXJncywgaW1wb3J0TWFwIH06IFVwZ3JhZGVDb21tYW5kT3B0aW9ucyxcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnByb3ZpZGVycyA9IEFycmF5LmlzQXJyYXkocHJvdmlkZXIpID8gcHJvdmlkZXIgOiBbcHJvdmlkZXJdO1xuICAgIGlmICghdGhpcy5wcm92aWRlcnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHVwZ3JhZGUgcHJvdmlkZXIgZGVmaW5lZCFgKTtcbiAgICB9XG4gICAgdGhpc1xuICAgICAgLmRlc2NyaXB0aW9uKCgpID0+XG4gICAgICAgIGBVcGdyYWRlICR7dGhpcy5nZXRNYWluQ29tbWFuZCgpLmdldE5hbWUoKX0gZXhlY3V0YWJsZSB0byBsYXRlc3Qgb3IgZ2l2ZW4gdmVyc2lvbi5gXG4gICAgICApXG4gICAgICAubm9HbG9iYWxzKClcbiAgICAgIC50eXBlKFwicHJvdmlkZXJcIiwgbmV3IEVudW1UeXBlKHRoaXMuZ2V0UHJvdmlkZXJOYW1lcygpKSlcbiAgICAgIC5vcHRpb24oXG4gICAgICAgIFwiLXIsIC0tcmVnaXN0cnkgPG5hbWU6cHJvdmlkZXI+XCIsXG4gICAgICAgIGBUaGUgcmVnaXN0cnkgbmFtZSBmcm9tIHdoaWNoIHRvIHVwZ3JhZGUuYCxcbiAgICAgICAge1xuICAgICAgICAgIGRlZmF1bHQ6IHRoaXMuZ2V0UHJvdmlkZXIoKS5uYW1lLFxuICAgICAgICAgIGhpZGRlbjogdGhpcy5wcm92aWRlcnMubGVuZ3RoIDwgMixcbiAgICAgICAgICB2YWx1ZTogKHJlZ2lzdHJ5KSA9PiB0aGlzLmdldFByb3ZpZGVyKHJlZ2lzdHJ5KSxcbiAgICAgICAgfSxcbiAgICAgIClcbiAgICAgIC5vcHRpb24oXG4gICAgICAgIFwiLWwsIC0tbGlzdC12ZXJzaW9uc1wiLFxuICAgICAgICBcIlNob3cgYXZhaWxhYmxlIHZlcnNpb25zLlwiLFxuICAgICAgICB7XG4gICAgICAgICAgYWN0aW9uOiBhc3luYyAoeyByZWdpc3RyeSB9KSA9PiB7XG4gICAgICAgICAgICBhd2FpdCByZWdpc3RyeS5saXN0VmVyc2lvbnMoXG4gICAgICAgICAgICAgIHRoaXMuZ2V0TWFpbkNvbW1hbmQoKS5nZXROYW1lKCksXG4gICAgICAgICAgICAgIHRoaXMuZ2V0VmVyc2lvbigpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIERlbm8uZXhpdCgwKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgKVxuICAgICAgLm9wdGlvbihcbiAgICAgICAgXCItLXZlcnNpb24gPHZlcnNpb246c3RyaW5nOnZlcnNpb24+XCIsXG4gICAgICAgIFwiVGhlIHZlcnNpb24gdG8gdXBncmFkZSB0by5cIixcbiAgICAgICAgeyBkZWZhdWx0OiBcImxhdGVzdFwiIH0sXG4gICAgICApXG4gICAgICAub3B0aW9uKFxuICAgICAgICBcIi1mLCAtLWZvcmNlXCIsXG4gICAgICAgIFwiUmVwbGFjZSBjdXJyZW50IGluc3RhbGxhdGlvbiBldmVuIGlmIG5vdCBvdXQtb2YtZGF0ZS5cIixcbiAgICAgIClcbiAgICAgIC5jb21wbGV0ZShcInZlcnNpb25cIiwgKCkgPT4gdGhpcy5nZXRBbGxWZXJzaW9ucygpKVxuICAgICAgLmFjdGlvbihhc3luYyAoeyByZWdpc3RyeSwgdmVyc2lvbjogdGFyZ2V0VmVyc2lvbiwgZm9yY2UgfSkgPT4ge1xuICAgICAgICBjb25zdCBuYW1lOiBzdHJpbmcgPSB0aGlzLmdldE1haW5Db21tYW5kKCkuZ2V0TmFtZSgpO1xuICAgICAgICBjb25zdCBjdXJyZW50VmVyc2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkID0gdGhpcy5nZXRWZXJzaW9uKCk7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGZvcmNlIHx8ICFjdXJyZW50VmVyc2lvbiB8fFxuICAgICAgICAgIGF3YWl0IHJlZ2lzdHJ5LmlzT3V0ZGF0ZWQobmFtZSwgY3VycmVudFZlcnNpb24sIHRhcmdldFZlcnNpb24pXG4gICAgICAgICkge1xuICAgICAgICAgIGF3YWl0IHJlZ2lzdHJ5LnVwZ3JhZGUoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG1haW4sXG4gICAgICAgICAgICBpbXBvcnRNYXAsXG4gICAgICAgICAgICBmcm9tOiBjdXJyZW50VmVyc2lvbixcbiAgICAgICAgICAgIHRvOiB0YXJnZXRWZXJzaW9uLFxuICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0QWxsVmVyc2lvbnMoKTogUHJvbWlzZTxBcnJheTxzdHJpbmc+PiB7XG4gICAgY29uc3QgeyB2ZXJzaW9ucyB9ID0gYXdhaXQgdGhpcy5nZXRWZXJzaW9ucygpO1xuICAgIHJldHVybiB2ZXJzaW9ucztcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRMYXRlc3RWZXJzaW9uKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgeyBsYXRlc3QgfSA9IGF3YWl0IHRoaXMuZ2V0VmVyc2lvbnMoKTtcbiAgICByZXR1cm4gbGF0ZXN0O1xuICB9XG5cbiAgcHVibGljIGdldFZlcnNpb25zKCk6IFByb21pc2U8VmVyc2lvbnM+IHtcbiAgICByZXR1cm4gdGhpcy5nZXRQcm92aWRlcigpLmdldFZlcnNpb25zKFxuICAgICAgdGhpcy5nZXRNYWluQ29tbWFuZCgpLmdldE5hbWUoKSxcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRQcm92aWRlcihuYW1lPzogc3RyaW5nKTogUHJvdmlkZXIge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gbmFtZVxuICAgICAgPyB0aGlzLnByb3ZpZGVycy5maW5kKChwcm92aWRlcikgPT4gcHJvdmlkZXIubmFtZSA9PT0gbmFtZSlcbiAgICAgIDogdGhpcy5wcm92aWRlcnNbMF07XG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVW5rbm93biBwcm92aWRlciBcIiR7bmFtZX1cImApO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdmlkZXI7XG4gIH1cblxuICBwcml2YXRlIGdldFByb3ZpZGVyTmFtZXMoKTogQXJyYXk8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXJzLm1hcCgocHJvdmlkZXIpID0+IHByb3ZpZGVyLm5hbWUpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJt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